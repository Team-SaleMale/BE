name: CD
# 목적: main 브랜치 변경 시 EC2에 연결해 Docker Compose로 재기동
# - dev → main 머지 자동화로 배포 기준 일관성 유지

on:
  # main 브랜치 푸시 시 자동 실행
  push:
    branches: [ main ]
  # 수동 실행 허용
  workflow_dispatch:

permissions:
  # dev → main 머지 후 push를 하기 위해 contents 쓰기 권한이 필요
  contents: write

jobs:
  deploy:
    # GitHub Actions 호스트 러너(빌드/머지 전용). 배포는 SSH로 EC2에서 진행
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      # 저장소 코드를 러너에 체크아웃(머지 작업에 필요)
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        fetch-tags: true
      
    - name: Merge dev to main
      # CI 단계에서 dev를 main에 병합하여 배포 기준을 dev 최신 상태로 맞춤
      # 주의: 팀 정책상 CI 머지를 원치 않으면 이 스텝 제거
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git checkout main
        git fetch origin dev
        git merge origin/dev
        git push origin main
        
    - name: Deploy to EC2
      # SSH로 EC2(프로덕션) 접속 후 배포 스크립트 실행
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USERNAME }}
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          # set -e: 실패 시 즉시 중단 → 불완전 배포 방지
          set -e
          # 프로젝트 디렉토리 준비 및 이동 (실제 저장소 경로)
          mkdir -p /home/ubuntu/salemale/BE
          cd /home/ubuntu/salemale/BE

          # Git 저장소 준비: 없으면 clone, 있으면 최신 main으로 동기화
          # 기존 배포 디렉토리 재활용 → 불필요한 클론/빌드 최소화
          if [ ! -d .git ]; then
            git clone https://github.com/Team-SaleMale/BE.git .
          fi
          git fetch --all --prune
          git checkout main || git checkout -b main origin/main
          git reset --hard origin/main
          
          # .env 파일 생성 (GitHub Secrets 사용)
          # 애플리케이션 환경 변수
          # 민감 정보는 GitHub Secrets에서 주입, 파일은 서버 로컬에만 존재
          cat > .env << EOF
          LOCAL_DB_URL=${{ secrets.RDS_URL }}
          LOCAL_DB_USERNAME=${{ secrets.RDS_USERNAME }}
          LOCAL_DB_PASSWORD=${{ secrets.RDS_PASSWORD }}
          ADMIN_USERNAME=${{ secrets.ADMIN_USERNAME }}
          ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD }}
          SPRING_PROFILES_ACTIVE=prod
          SERVER_PORT=8080
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_EXPIRATION=${{secrets.JWT_EXPIRATION}}
          JWT_ACCESS_TOKEN_VALIDITY=${{ secrets.JWT_ACCESS_TOKEN_VALIDITY }}
          JWT_REFRESH_TOKEN_VALIDITY=${{ secrets.JWT_REFRESH_TOKEN_VALIDITY }}
          DOCKERHUB_USERNAME=${{ secrets.DOCKER_USERNAME }}
          REDIS_HOST=${{ secrets.REDIS_HOST }}
          REDIS_PORT=${{ secrets.REDIS_PORT }}
          GOOGLE_EMAIL=${{ secrets.GOOGLE_EMAIL }}
          GOOGLE_APP_PW=${{ secrets.GOOGLE_APP_PW }}
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          KAKAO_CLIENT_ID=${{ secrets.KAKAO_CLIENT_ID }}
          KAKAO_CLIENT_SECRET=${{ secrets.KAKAO_CLIENT_SECRET }}
          KAKAO_REDIRECT_URI=${{ secrets.KAKAO_REDIRECT_URI }}
          NAVER_CLIENT_ID=${{ secrets.NAVER_CLIENT_ID }}
          NAVER_CLIENT_SECRET=${{ secrets.NAVER_CLIENT_SECRET }}
          NAVER_REDIRECT_URI=${{ secrets.NAVER_REDIRECT_URI }}
          AWS_S3_BUCKET_NAME=${{ secrets.AWS_S3_BUCKET_NAME }}
          AWS_S3_REGION=${{ secrets.AWS_S3_REGION }}
          AWS_ACCESS_KEY=${{ secrets.AWS_ACCESS_KEY }}
          AWS_SECRET_KEY=${{ secrets.AWS_SECRET_KEY }}
          GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
          RECOMMENDATION_API_URL=${{ secrets.RECOMMENDATION_API_URL }}
          EOF
          
          # Docker Compose v2/v1 자동 감지
          if docker compose version >/dev/null 2>&1; then
            DC="docker compose"
            WAIT_FLAG="--wait"  # v2만 지원
          else
            DC="docker-compose"
            WAIT_FLAG=""
          fi

          # 프로젝트명 고정 → 네트워크/컨테이너 명명 일관성
          export COMPOSE_PROJECT_NAME=salemale

          # 1) down: 이전 리소스 정리(다운타임 허용) 후 재기동
          $DC down --remove-orphans || true

          # 2) 남아있는 컨테이너 강제 제거 (이름 충돌 방지)
          # docker-compose down 후에도 남아있을 수 있는 컨테이너 정리
          docker rm -f salemale-app salemale-redis >/dev/null 2>&1 || true
          # 모든 salemale-* 컨테이너 제거 (혹시 모를 경우 대비)
          docker ps -a --filter "name=salemale-" --format "{{.ID}}" | while read id; do [ -n "$id" ] && docker rm -f "$id" || true; done

          # 3) 네트워크 확인 및 생성 (없으면 생성, 있으면 사용)
          docker network create salemale-network >/dev/null 2>&1 || true
          # 4) pull: 최신 이미지 당김(롤아웃 전 준비)
          $DC pull
          # 5) up: 강제 재생성, v2면 헬스체크 healthy까지 대기
          $DC up -d --force-recreate --remove-orphans $WAIT_FLAG
          
          # 배포 상태 확인
          # 컨테이너 목록 출력 → 최종 점검
          sleep 10
          $DC ps

